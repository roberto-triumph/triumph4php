/**
 * This software is released under the terms of the MIT License
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @copyright  2009-2011 Roberto Perpuly
 * @license    http://www.opensource.org/licenses/mit-license.php The MIT License
 */
#ifndef __MVCEDITOR_ACTIONCLASS_H__
#define __MVCEDITOR_ACTIONCLASS_H__

#include <wx/thread.h>
#include <wx/event.h>
#include <wx/timer.h>
#include <queue>

namespace mvceditor {

// defined below
class RunningThreadsClass;

/**
 * This event will be generated when the thread has completed its job
 * **successfully** A thread that has been stopped via RunningThreads::Stop()
 * or will still generate this event.
 */
extern const wxEventType EVENT_WORK_COMPLETE;

/**
 * This event will be generated when the thread is in action. Event listeners
 * can do things like update status bars here.
 * event.GetString() may have a message describing the action being taken
 */
extern const wxEventType EVENT_WORK_IN_PROGRESS;

class ActionClass {

public:

	ActionClass(mvceditor::RunningThreadsClass& runningThreads, int eventId);

	virtual ~ActionClass();

	/**
	 * This is the method to override; this method is executed in the background thread.
	 */
	virtual void BackgroundWork() = 0;

	/**
	 * @return wxString a short description of this action.
	 */
	virtual wxString GetLabel() const = 0;

	/**
	 * if the thread allocates any dynamic memory (using NEW) but this thread is
	 * Delete()'d before the thread gets a chance to wxPostEvent() to the main
	 * thread, then it should delete the memory in this method. This method will
	 * get called in the background thread.
	 */
	virtual void BackgroundCleanup();

	/**
	 * ask the action to stop.  the action will then stop as soon as possible but will
	 * do so while retaining a clean state.
	 *
	 * this method can be called from a different thread
	 */
	void Cancel();

	/**
	 * Will generate a EVENT_WORK_COMPLETE event and stop the EVENT_WORK_IN_PROGRESS events.
	 * Does not actually stop the thread.
	 */
	void SignalEnd();

	/**
	 * @return int the event ID for this action
	 */
	int GetEventId() const;

	/**
	 * a number used to identify this action; will be used to cancel the action.
	 * usually, this action ID is used in conjunction with RunningThreads class.
	 */
	void SetActionId(int actionId);

	/**
	 * get the ID of this action.
	 * usually, the action ID is used in conjunction with RunningThreads class.
	 */
	int GetActionId();

protected:

	/**
	 * Generates a EVENT_ACTION_STATUS event with the given string
	 * as the wxCommandEvent.GetString
	 */
	void SetStatus(const wxString& status);

	/**
	 * send an event to all of the handlers that have registered via RunningThreads::AddHandler
	 * method.
	 */
	void PostEvent(wxEvent& event);

	/**
	 * subclasses should call this method often in the BackgroundWork() method; subclasses
	 * should exit the BackgroundWork() method after IsCancelled() returns TRUE
	 */
	bool IsCancelled();

private:

	/**
	 * Keeps a reference to this object's running thread; that way
	 * we can send events to other threads.
	 */
	mvceditor::RunningThreadsClass& RunningThreads;

	/**
	 * All events generated by this action will have this ID as their EventId
	 */
	int EventId;

	/**
	 * a number used to identify this action; will be used to cancel the action.
	 * usually, this action ID is used in conjunction with RunningThreads class.
	 */
	int ActionId;

	/**
	 * the mutext controls access to Cancelled boolean
	 */
	wxMutex Mutex;

	/**
	 * flag to signal that the action should return immediately even if it has 
	 * not completed its work.
	 */
	bool Cancelled;
};

/**
 * A small class that will run in a background thread, look at a queue
 * of ActionClass instances and Run each action (call BackgroundWork()) in the 
 * background thread.
 * This class will continually poll the queue, pop actions off the
 * queue, call BackgroundWork() on them, and delete them once
 * BackgroundWork() has finished.
 */
class ThreadActionClass : public wxThread {

public:

	/**
	 *
	 * @param actions to be run; First In First Out
	 *        this class will continually poll the queue, pop actions off the
	 *        queue, call BackgroundWork() on them, and delete them once
	 *        BackgroundWork() has finished.
	 * @param actionsMutex to prevent simultaneous access to Actions
	 * @param finishSemaphore to signal when all actions have been cleaned up
	 */
	ThreadActionClass(std::queue<mvceditor::ActionClass*>& actions, wxMutex& actionsMutex,
		wxSemaphore& finishSemaphore);

	void* Entry();

private:

	/**
	 * actions to be run; First In First Out
	 */
	std::queue<mvceditor::ActionClass*>& Actions;

	/**
	 * Prevent simultaneous access to Actions
	 */
	wxMutex& ActionsMutex;

	/**
	 * this is to signal when the background task has finished cleanup
	 */
	wxSemaphore& FinishSemaphore;

	/**
	 * @return action  next action from the queue, or NULL if queue is empty
	 */
	mvceditor::ActionClass* NextAction();

	void ActionComplete();
  };
  
/**
 * Class to hold all of the threads that are currently running.  wxWidgets
 * threads are detached by default, we cannot call the IsRunning or IsAlive
 * methods on them; this makes it necessary for us to track the threads
 * in order to stop them on demand (like say, when the user clicks a stop
 * button or closes a panel).
 * 
 * This class will own the given threads, and will delete them if need be.
 */
class RunningThreadsClass : public wxEvtHandler {
  
  	public:
  	
	RunningThreadsClass(bool doPostEvents = true);
	
	/**
	 * Keeps track of the given worker.  Most of the times we will
	 * do nothing with this pointer; wxWidgets detached threads delete themselves.
	 * The only time we will need this pointer is when we want to stop
	 * the thread while it is running. Remember that it is not safe to
	 * call IsAlive, IsRunning methods on detached threads.
	 * 
	 * @param action this class will own the pointer and delete it
	 * @return an action ID, which can be used to cancel the action at at 
	 * later time.
	 */
	int Add(mvceditor::ActionClass* action);

	/**
	 * gracefully stops the given action, allowing the other added actions
	 * to keep going. If the action is running it is cancelled. if it is not
	 * running, it will be removed from the queue and deleted.
	 *
	 * @param int actionID as given by the Add() method
	 */
	void CancelAction(int actionId);

	/**
	 * stop all of the running threads. This method is guaranteed to block
	 * until all threads have terminated. If this method is hanging 
	 * indefinitely, it means that one of the running threads has not
	 * been calling Cancel() correctly.
	 */
	void StopAll();

	/**
	 * adds an event handler to this instance.  Running threads will
	 * post events to all registered handlers.  The handlers pointer
	 * is NOT owned by this object; the caller must ensure to call
	 * RemoveEventHandler before the event handler goes out of scope.
	 */
	void AddEventHandler(wxEvtHandler* handler);

	/**
	 * removes event handler to this instance, if handler has
	 * not been registered then this method does nothing.
	 */
	void RemoveEventHandler(wxEvtHandler* handler);

	/**
	 * post an event (using wxPostEvent) to all registered handlers.
	 * this means that the event will be received in the next event loop.
	 */
	void PostEvent(wxEvent& event);
  
	/**
	 * Check to see if the given thread is being tracked; if it was previously
	 * added with the Add() method but not yet removed via the Remove() or Stop()
	 * methods.  If this returns true, then it means that the thread is definitely alive.
	 * This is safe to call on detached or joinable threads, as it does not depend
	 * on wxThread::IsAlive or  wxThread::IsRunning methods.
	 */
	//bool IsRunning(mvceditor::ThreadWithHeartbeatClass* thread);
  
	private:
  
	/**
	 * holds all actions that need to be run. This class will add 
	 * actions to the queue.
	 */
	std::queue<mvceditor::ActionClass*> Actions;
  
	/**
	 * Prevent simultaneous access to Actions
	 */
	wxMutex ActionMutex;

	/**
	 * this is the background thread that pops items from the action queue
	 * and actually runs the actions
	 */
	mvceditor::ThreadActionClass* ThreadAction;
	
	/**
	 * holds all event handlers to post events to. This object
	 * will not own these pointers.
	 */
	std::vector<wxEvtHandler*> Handlers;
	
	/**
	 * prevent concurrent access to the handlers
	 */
	wxMutex HandlerMutex;	
	
	/**
	 * to implement blocking wait when stopping the background
	 * threads
	 */
	wxSemaphore Semaphore;
  
	/**
	 * wheter to send events in the current event loop or the next event
	 * loop (wxPostEvent vs. ProcessEvent() ) .  this flag is used for
	 * unit tests since we don't have an event loop in the unit tests.
	 */
	bool DoPostEvents;

	/**
	 * a number that uniquely identifies an action. no two queued actions will have
	 * the same ID.
	 */
	int NextActionId;

	/**
	 *  To generate the heartbeats (EVENT_WORK_IN_PROGRESS)
	 */
	wxTimer Timer;
	
	/**
	 * Will generate a EVENT_WORK_IN_PROGRESS event
	 */
	void OnTimer(wxTimerEvent& event);
	
	/**
	 * Will prepare to send events at regular intervals. After a call to this method, a 
	 * EVENT_WORK_IN_PROGRESS will be generated at regular intervals until SignalEnd()
	 * is called.
	 */
	void SignalStart();

	DECLARE_EVENT_TABLE() 
};

/**
 * event identifiers for all actions. These should be used
 * as the eventIDs for the corresponding actions unless 
 * it is not possible.
 * start at 20,000 to prevent collison with feature menu IDs
 * ID_MENU_*
 */
 enum {
	ID_EVENT_ACTION_GLOBAL_CACHE_INIT = wxID_HIGHEST + 20000,
	ID_EVENT_ACTION_GLOBAL_CACHE,
	ID_EVENT_ACTION_SQL_METADATA_INIT,
	ID_EVENT_ACTION_SQL_METADATA,
	ID_EVENT_ACTION_URL_TAG_DETECTOR_INIT,
	ID_EVENT_ACTION_URL_TAG_DETECTOR,
	ID_EVENT_ACTION_CALL_STACK,
	ID_EVENT_ACTION_TEMPLATE_FILE_TAG_DETECTOR,
	ID_EVENT_ACTION_TAG_DETECTOR_INIT,
	ID_EVENT_ACTION_TAG_DETECTOR,
	ID_EVENT_ACTION_DATABASE_TAG_DETECTOR_INIT,
	ID_EVENT_ACTION_DATABASE_TAG_DETECTOR,
	ID_EVENT_ACTION_CONFIG_TAG_DETECTOR,
	ID_EVENT_ACTION_GLOBAL_CACHE_WIPE,
	ID_EVENT_ACTION_TAG_CACHE_VERSION_CHECK,
	ID_EVENT_ACTION_DETECTOR_CACHE_VERSION_CHECK
 };
 
/*
 * this event will be generated while a sequence is running, it
 * is generated everytime the status of the sequence changes. The
 * new status of the sequence can be retrieved via wxCommandEvent.GetString
 */
extern const wxEventType EVENT_ACTION_STATUS;

}

#endif