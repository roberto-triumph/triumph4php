/**
 * This software is released under the terms of the MIT License
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @copyright  2014 Roberto Perpuly
 * @license    http://www.opensource.org/licenses/mit-license.php The MIT License
 */
#ifndef __T4P_DEBUGGERFEATURECLASS_H__
#define __T4P_DEBUGGERFEATURECLASS_H__

#include <boost/asio.hpp>
#include <features/FeatureClass.h>
#include <actions/ActionClass.h>
#include <language/DbgpEventClass.h>
#include <features/wxformbuilder/DebuggerFeatureForms.h>
#include <wx/thread.h>
#include <wx/stc/stc.h>
#include <vector>
#include <queue>

namespace t4p {

// forward declaration, defined below
class DebuggerPanelClass;

/**
 * event generated by the background thread when it receives
 * a response from the debug engine.  The event will contain
 * the unparsed xml string exactly as the debug engine sent it.
 * The event is of type wxThreadEvent.
 */
extern const wxEventType EVENT_DEBUGGER_LOG;

#define EVT_DEBUGGER_LOG(id, fn) \
	DECLARE_EVENT_TABLE_ENTRY(t4p::EVENT_DEBUGGER_LOG, id, -1, \
    (wxObjectEventFunction) (wxEventFunction) \
    wxStaticCastEvent( wxThreadEventFunction, & fn ), (wxObject *) NULL ),

/**
 * event generated by the background thread when it receives
 * a response from the debug engine.  The event will contain
 * the PARSED object. The event is one of the Dbgp*Event
 * classes.
 */
extern const wxEventType EVENT_DEBUGGER_RESPONSE;

/**
 * event generated by the main thread when it receives
 * input from the user. For example, the main thread will
 * send a step-over command when the user wants to step
 * to the next line of code. The event is of type wxThreadEvent.
 */
extern const wxEventType EVENT_DEBUGGER_CMD;

/**
 * the debugger server action listens for connections from the 
 * debug engine (xdebug) in a background thread.  The debugger
 * server action parses the xdebug responses and publishes
 * t4p::DBGP_* events.
 *
 * This action is a bit different from other actions in that the action
 * will also listen for events from the main thread. the main thread
 * will send commands that should be sent over to the debug engine, like
 * step in, step over, step out. A command is nothing more than a string
 * that was put together with DbgpCommandClass.
 */
class DebuggerServerActionClass : public wxEvtHandler, public t4p::ActionClass {

public:

	DebuggerServerActionClass(t4p::RunningThreadsClass& runningThreads, int eventId, t4p::EventSinkLockerClass& eventSinkLocker);

	~DebuggerServerActionClass();
	
	/**
	 * set the port that will be listened on.  this should be the same as the "xdebug.remote_port"
	 * setting in the user's php.ini.
	 */
	void Init(int port);

protected:

	/**
	 * this method contains the "main loop" of the socket service. we will
	 * continously listen for new responses and send new commands.
	 * we will also listen for a triumph-only special "close" message to
	 * be able to close the socket properly.
	 */
	void BackgroundWork();

	/**
	 * parses the xdebug xml response into the approprivate DbgpEvent class
	 * and posts the event.
	 *
	 * @param xml the xml response from xdebug
	 * @param cmd the command that we sent to xdebug 
	 * @param [out] isDebuggerStopped will be set to TRUE when the debugger responds
	 *        that the script has finished running (ie. "step over" the last line of the script)
	 */
	void ParseAndPost(const wxString& xml, const std::string& cmd, bool& isDebuggerStopped);

	wxString GetLabel() const;

	/**
	 * the loop for each debugger seesion (script)
	 */
	void SessionWork(boost::asio::ip::tcp::socket& socket);

	/**
	 * adds a command to be sent over to the debug engine. adding is
	 * done safely by using the mutex.
	 */
	void AddCommand(std::string cmd);

	/**
	 * @return the next command to send, empty string if there are no more commands
	 *         to send. the command is removed from the queue.
	 *         this method safely removes from the queue by using the mutex.
	 */
	std::string NextCommand();

	/**
	 * send a log event; this is usually the command we send to xdebug or
	 * the response we get back
	 */
	void Log(const wxString& title, const wxString& msg);

	/**
	 * handler of the EVENT_DEBUGGER_CMD event. adds the command
	 * to be sent over to the debug engine after all previously queues
	 * commands have been sent.
	 */
	void OnCmd(wxThreadEvent& event);

	/**
	 * commands to be sent by triumph to the debugger engine. These strings
	 * are built with DbgpCommandClass. Examples of commands: set a 
	 * breakpoint, get a variable value, get the runtime stack
	 */
	std::queue<std::string> Commands;
	
	/**
	 * prevent simulatenous access to commands list
	 */
	wxMutex CommandMutex;

	/**
	 * the io service listens on the socket for
	 * information from the debugger engine
	 */
	boost::asio::io_service IoService;

	/**
	 * we use the event sink to get commands from the foreground thread.
	 * for example, the user clicks the "step out" command the
	 * foreground thread will post a command to this event sink.
	 * the server action will listen for the commands an send them to
	 * the debug engine.
	 */
	t4p::EventSinkLockerClass& EventSinkLocker;

	/**
	 * used to build the xdebug commands. using a class-wide instance
	 * because xdebug commands require a unique "transactionId"
	 */
	t4p::DbgpCommandClass Cmd;

	/**
	 * the port number to listen on.  This is the same port
	 * that the user will set on their php.ini file for
	 * "xdebug.remote_port"
	 */
	int Port;
};

/**
 * a small class that holds a debugger breakpoint along with
 * its "handle". A "handle" is an opaque ID that is assigned
 * by STC, that way we can track movements of the breakpoint
 * when code is added or deleted.
 */
class BreakpointWithHandleClass {

public:

	/**
	 * the line number where the breakpoint is located.
	 */
	t4p::DbgpBreakpointClass Breakpoint;

	/**
	 * A "handle" is an opaque ID that is assigned
	 * by STC, that way we can track movements of the breakpoint
	 * when code is added or deleted.
	 */
	int Handle;

	/**
	 * this is the TransactionID of the command that we sent to 
	 * xdebug. Transaction Id is an arbritary string that is unique
	 * to the debug engine. We need to keep track of this because
	 * the xdebug response to breakpoint_set only returns the
	 * transaction Id; we need to save the 
	 * breakpoint Id that we get from Xdebug so that we can later
	 * remove or disable the breakpoint if the user wants to.
	 */
	std::string DbgpTransactionId;

	BreakpointWithHandleClass();

	BreakpointWithHandleClass(const t4p::BreakpointWithHandleClass& src);

	t4p::BreakpointWithHandleClass& operator=(const t4p::BreakpointWithHandleClass& src);

	void Copy(const t4p::BreakpointWithHandleClass& src);
};

/**
 * This feature accepts connections from x-debug.
 */
class DebuggerFeatureClass : public t4p::FeatureClass {

public:

	DebuggerFeatureClass(t4p::AppClass& app);

	void AddNewMenu(wxMenuBar* menuBar);

	/**
	 * issues a debugger command to get the children of the given
	 * property. The command is asynchronous; this method exits 
	 * immediately, and the command is queued to be sent to 
	 * the debugger over a socket on a background thread.
	 *
	 * See section 7.13 of the xdbgp protocol docs.
	 */
	void CmdPropertyGetChildren(const t4p::DbgpPropertyClass& prop);

private:

	// handlers for menu items
	void OnStartDebugger(wxCommandEvent& event);
	void OnBreakAtStart(wxCommandEvent& event);
	void OnStepInto(wxCommandEvent& event);
	void OnStepOver(wxCommandEvent& event);
	void OnStepOut(wxCommandEvent& event);
	void OnContinue(wxCommandEvent& event);
	void OnContinueToCursor(wxCommandEvent& event);
	void OnToggleBreakpoint(wxCommandEvent& event);

	/**
	 * turn on or off a debugger breakpoint at the currently 
	 * focused file at the given line.
	 *
	 * @param codeCtrl the code control to toggle the breakpoint from
	 * @param lineNumber 1-based line number
	 */
	void ToggleBreakpointAtLine(t4p::CodeControlClass* codeCtrl, int lineNumber);

	/**
	 * when the user clicks on the margin of a code control, toggle
	 * a debugger breakpoint at the line that was clicked on
	 */
	void OnMarginClick(wxStyledTextEvent& event);

	// handlers to begin/stop listening on serveer
	void OnAppReady(wxCommandEvent& event);
	void OnAppExit(wxCommandEvent& event);

	/**
	 * updates the GUI to alert the user that the script has finished running
	 * and that the debugger session has closed.
	 */
	void ResetDebugger();

	// below are the handlers for all responses from the debug engine
	void OnDbgpInit(t4p::DbgpInitEventClass& event);
	void OnDbgpError(t4p::DbgpErrorEventClass& event);
	void OnDbgpStatus(t4p::DbgpStatusEventClass& event);
	void OnDbgpFeatureGet(t4p::DbgpFeatureGetEventClass& event);
	void OnDbgpFeatureSet(t4p::DbgpFeatureSetEventClass& event);
	void OnDbgpContinue(t4p::DbgpContinueEventClass& event);
	void OnDbgpBreakpointSet(t4p::DbgpBreakpointSetEventClass& event);
	void OnDbgpBreakpointGet(t4p::DbgpBreakpointGetEventClass& event);
	void OnDbgpBreakpointUpdate(t4p::DbgpBreakpointUpdateEventClass& event);
	void OnDbgpBreakpointRemove(t4p::DbgpBreakpointRemoveEventClass& event);
	void OnDbgpBreakpointList(t4p::DbgpBreakpointListEventClass& event);
	void OnDbgpStackDepth(t4p::DbgpStackDepthEventClass& event);
	void OnDbgpStackGet(t4p::DbgpStackGetEventClass& event);
	void OnDbgpContextNames(t4p::DbgpContextNamesEventClass& event);
	void OnDbgpContextGet(t4p::DbgpContextGetEventClass& event);
	void OnDbgpPropertyGet(t4p::DbgpPropertyGetEventClass& event);
	void OnDbgpPropertyValue(t4p::DbgpPropertyValueEventClass& event);
	void OnDbgpPropertySet(t4p::DbgpPropertySetEventClass& event);
	void OnDbgpBreak(t4p::DbgpBreakEventClass& event);
	void OnDbgpEval(t4p::DbgpEvalEventClass& event);

	/**
	 * this is an additional debug engine handler, we log the exact
	 * response we get back from the debug engine 
	 */
	void OnDebuggerLog(wxThreadEvent& event);

	/**
	 * send a command to the debug engine.  This is an asynchronous
	 * operation; we send the command over to the background thread,
	 * and the background thread sends the command to the debug engine.
	 *
	 * @param cmd the command string to send, built by DbgpCommandClass
	 */
	void PostCmd(std::string cmd);

	/**
	 * holds the background thread that the server action is running
	 * in
	 */
	t4p::RunningThreadsClass RunningThreads;

	/**
	 * this event sink is used to "pass" debug commands such as step out,
	 * step into and step over, to the background thread.
	 */
	t4p::EventSinkLockerClass EventSinkLocker;

	/**
	 * the breakpoints that the user has set.
	 */
	std::vector<t4p::BreakpointWithHandleClass> Breakpoints;

	/**
	 * used to build the xdebug commands. using a class-wide instance
	 * because xdebug commands require a unique "transactionId"
	 */
	t4p::DbgpCommandClass Cmd;

	/**
	 * TRUE if the debugger session is currently being handled.  When
	 * the debug session is active, we want to immediately tell
	 * the debug engine when the user adds or removes a breakpoint.
	 */
	bool IsDebuggerSessionActive;

	t4p::DebuggerPanelClass* DebuggerPanel;

	DECLARE_EVENT_TABLE()
};

/**
 * shows a log of the data that was sent by the debugger engine xdebug
 */
class DebuggerLogPanelClass : public DebuggerLogPanelGeneratedClass {

public:

	DebuggerLogPanelClass(wxWindow* parent);

	void Append(const wxString& text);

private:

	void OnClearButton(wxCommandEvent& event);
};

/**
 * shows the current run-time stack (the function/method that is being 
 * run along with all of the functions/methods that called it).
 */
class DebuggerStackPanelClass : public DebuggerStackPanelGeneratedClass {

public:

	DebuggerStackPanelClass(wxWindow* parent, int id);

	void ShowStack(const std::vector<t4p::DbgpStackClass>& stack);

	void ClearStack();

private:

};

class DebuggerVariablePanelClass : public DebuggerVariablePanelGeneratedClass {

public:

	DebuggerVariablePanelClass(wxWindow* parent, int id, t4p::DebuggerFeatureClass& feature);

	void AddVariables(const std::vector<t4p::DbgpPropertyClass>& variables);

	void ClearVariables();

	void UpdateVariable(const t4p::DbgpPropertyClass& variable);

private:

	void OnVariableExpanding(wxDataViewEvent& event);

	/**
	 * we will use the feature to get the entire variable properties when
	 * a variable is being expanded.
	 */
	t4p::DebuggerFeatureClass& Feature;

	DECLARE_EVENT_TABLE()
};

/**
 * this class represents a single "node" in the variable data view model. a node is
 * equal to a single DbgpPropertyClass instance, along with pointers to its parent
 * property and children properties.
 * 
 * A node will own its children.
 */
class DebuggerVariableNodeClass {

public:

	t4p::DbgpPropertyClass Property;

	/**
	 * this instance will not own the parent pointer
	 */
	t4p::DebuggerVariableNodeClass* Parent;

	/**
	 * this instance WILL own the children pointers and
	 * will delete them 
	 */
	std::vector<t4p::DebuggerVariableNodeClass*> Children;

	/**
	 * this instance will not own the parent pointer
	 */
	DebuggerVariableNodeClass(t4p::DebuggerVariableNodeClass* parent);

	/**
	 * this instance will not own the parent pointer
	 */
	DebuggerVariableNodeClass(t4p::DebuggerVariableNodeClass* parent, const t4p::DbgpPropertyClass& prop);

	~DebuggerVariableNodeClass();

	/**
	 * deletes all of the items in Children, and adds newChildren to the 
	 * Children vector. This instance will now own the pointers in newChildren.
	 */
	void ReplaceChildren(const std::vector<t4p::DbgpPropertyClass>& newChildren, wxDataViewModel* model);
};

/**
 * this class is used as the "data view model" it is a requirement
 * because we are using a wxDataViewCtrl to show variables
 */
class DebuggerVariableModelClass : public wxDataViewModel {

public:

	DebuggerVariableModelClass();

	// Override this so the control can query the child items of an item.     
	virtual unsigned int GetChildren(const wxDataViewItem& item, wxDataViewItemArray& children) const;
 
	// Override this to indicate the number of columns in the model. 
	virtual unsigned int GetColumnCount() const;
 	
	// Override this to indicate what type of data is stored in the column specified by col. 
	virtual wxString GetColumnType(unsigned int col) const;
 
	// Override this to indicate which wxDataViewItem representing the parent of item or an 
	// invalid wxDataViewItem if the root item is the parent item. 
	virtual wxDataViewItem GetParent(const wxDataViewItem& item) const;

	virtual bool HasContainerColumns(const wxDataViewItem& item) const;
 	
	 // Override this to indicate the value of item. 
	virtual void GetValue(wxVariant& variant, const wxDataViewItem& item, unsigned int col) const;
 
	// Override this to indicate of item is a container, i.e. if it can have child items. 
	virtual bool IsContainer(const wxDataViewItem& item) const;
 	
	// This gets called in order to set a value in the data model. 
	virtual bool SetValue(const wxVariant &variant, const wxDataViewItem &item, unsigned int col);
 
	void SetVariables(const std::vector<t4p::DbgpPropertyClass>& variables);

	/**
	 * recurses down through the model's nodes until it finds the variable that was updated.
	 * this method will then remove the found node's children and replace them with the
	 * given variables children. 
	 *
	 * this method is typically called when the user expands a variable to see the variable's
	 * sub-properties.
	 *
	 * @param variable the new variable properties; these come from the debug engine
	 * @param updatedItem [out] will be set to the item that was updated.
	 */
	void UpdateVariable(const t4p::DbgpPropertyClass& variable, wxDataViewItem& updatedItem);

private:

	t4p::DebuggerVariableNodeClass RootVariable;
};


/**
 * shows the bulk of the debug information
 */
class DebuggerPanelClass : public DebuggerPanelGeneratedClass {

public:

	t4p::DebuggerLogPanelClass* Logger;
	t4p::DebuggerVariablePanelClass* VariablePanel;

	DebuggerPanelClass(wxWindow* parent, int id, t4p::DebuggerFeatureClass& feature);

private:
};

}

#endif